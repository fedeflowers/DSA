"""
```markdown
# Explanation of the LeetCode Solution for "4 Keys Keyboard"

## 1. Brief Explanation of the Approach

The solution uses dynamic programming to determine the maximum number of 'A's that can be produced with `n` keystrokes on a keyboard that supports four keys: 'A', 'Ctrl-A', 'Ctrl-C', and 'Ctrl-V'. 

Here's a step-by-step breakdown of how the solution works:

- **Dynamic Programming Array**: We initialize a list `dp` where `dp[i]` represents the maximum number of 'A's that can be produced with `i` keystrokes.
  - For keystrokes 0 to 6, the maximum number of 'A's simply equals the number of keystrokes (i.e., pressing 'A' the number of times equal to the keystroke count).

- **Main Loop** (`for i in range(7, n + 1)`): 
  - We start iterating from 7 keystrokes because with less than 7 keystrokes, no full sequence of Ctrl-A and Ctrl-C can be executed, thus making it inefficient to apply pasting strategies.
  
- **Inner Loop** (`for j in range(i - 3, 0, -1)`):
  - For each `i`, the inner loop checks all possible previous states (`j`) to determine how many 'A's can be generated by performing the following sequence:
    1. Press 'Ctrl-A' to select all that is currently on the screen.
    2. Press 'Ctrl-C' to copy.
    3. Then, the remaining keystrokes `(i - j - 1)` can be used to paste.
  
  - The expression `dp[j] * (i - j - 1)` calculates the maximum number of 'A's that can be produced if the state just before pasting was `dp[j]`.

- **Final Output**: The maximum number of 'A's possible after `n` keystrokes is returned as `dp[n]`.

## 2. Time and Space Complexity Analysis

- **Time Complexity**: 
  - The outer loop runs from `7` to `n`, which is O(n).
  - The inner loop runs from `i-3` down to `1`, which takes O(n) in the worst case as it can iterate almost `i`.
  - Thus, the overall time complexity is approximately O(n^2) in the worst case.

- **Space Complexity**: 
  - The space complexity is O(n) due to the `dp` array, which stores results for every keystroke count up to `n`.

## 3. Why This Approach is Efficient

The dynamic programming approach efficiently computes the maximum number of 'A's without needing to simulate each keystroke individually. By breaking the problem into smaller subproblems (the maximum counts for fewer keystrokes) and using previously computed results to build up to the solution for `n` keystrokes, we avoid recalculating results repetitively.

Additionally, by leveraging the sequence of 'Ctrl-A', 'Ctrl-C', and subsequent 'Ctrl-V', the algorithm efficiently calculates the most productive keystrokes by focusing on the important combinations and maximizing the outputs based on prior results, thus making the solution both optimal and clear.
```

Runtime: undefined
Memory: 19412000
"""

class Solution:
    def maxA(self, n: int) -> int:
        dp = [i for i in range(n + 1)]
        for i in range(7, n + 1):
            for j in range(i - 3, 0, -1):
                # dp[j] is the count before Ctrl-A, Ctrl-C (2 steps)
                # (i - j - 1) is the multiplier (1 base + number of pastes)
                dp[i] = max(dp[i], dp[j] * (i - j - 1))
        return dp[n]
